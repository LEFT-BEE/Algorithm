## Tree 형태와 Heap

안녕하세요 오늘은 힙 자료구조에 대해 공부하도록 하겠습니다.

힙은 최솟값 또는 최대값을 빠르게 찾아내기 위해 완전 이진트리 형태로 만들어진 자료구조입니다.  

기본적으로 트리란 아래와 같은 구조입니다. 

<img src="https://user-images.githubusercontent.com/65720894/139640230-d7c21cb0-fc4f-4cb0-ba49-0df8b58a285e.png" width="500" height="350">
여기서 각 요소가 들어있는 공간을 노트라 말하고 특정 깊이에 있는 노드들의 집합을 레벨이라고 말합니다.   
그리고 이진 트리는 모든 노드의 자식 노드를 2개 밖에 못갖는 것을 의미합니다. 위의 트리에서는 B노드의 자식노드가 3개이므로
이진 트리라고 할 수 없습니다.

<img src="https://user-images.githubusercontent.com/65720894/139639198-efb22009-b991-40b4-b5d4-6fa084b43f04.png" width="500" height="350">

완전 이진 트리(complete binary tree)'란 마지막 레벨을 제외한 모든 노드가 채워져있으면서 모든 노드가 왼쪽 부터 채워져 있어야 하는 트리를 말합니다.     
그렇다면 어떻게 힙이 구현이 되는 것일까요?

예를 들어보면 어떤 리스트에 값을 넣었다가 빼낼려고 할 때, 우선순위가 높은 것 부터 빼내려고 한다면 대개 정렬을 떠올리게 됩니다. 
쉽게 생각해서 숫자가 낮을 수록 우선순위가 높다고 가정할 때 매 번 새 원소가 들어올 때 마다 이미 리스트에 있던 원소들과 비교를 하고 정렬을 해야하는데
문제는 이런식으로 구현할 시 비효율적이기 떄문에 좀 더 효율이 좋게 만들기 위해 아래 조건을 붙힙니다.   

"부모노드는 항상 자식 노드보다 우선 순위가 높다"

즉, 모든 요소들을 고려하여 우선순위를 정할 필요 없이 부모노드는 자식노드보다 항상 우선 순위가 앞선다는 조건만 만족시키며 완전이진트리 
형태로 채워나가는 것이다.

<img src ="https://user-images.githubusercontent.com/65720894/139639549-01097294-cbbe-428f-ab56-86b56cf94989.png" width ="500" height ="350">

이로인해 루트 노드는 항상 우선순위가 제일 높은 노드가 된다는 것입니다. 이러한 원리로 최대값 혹은 최솟값을 빠르게 찾아낼 수 있다는 장점(시간복잡도 O(1))
과 함께 삽입 삭제 연산시에도 부모노드가 자식노드보다 우선순위만 높으면 되므로 결국 트리의 깊이만큼만 비교를 하면 되기 때문에 O(logN)의 시간 복잡도를 가집니다

---
## 관련문제

### 문제

문제는 프로그래머스 코딩테스트 연습의 "더 맵게"에서 가져왔습니다.
```
매운 것을 좋아하는 Leo는 모든 음식의 스코빌 지수를 K 이상으로 만들고 싶습니다. 
모든 음식의 스코빌 지수를 K 이상으로 만들기 위해  Leo는 스코빌 지수가 가장 낮은 
두 개의 음식을 아래와 같이 특별한 방법으로 섞어 새로운 음식을 만듭니다.

"섞은 음식의 스코빌 지수 = 가장 맵지 않은 음식의 스코빌 지수 + (두 번째로 맵지 않은 음식의 스코빌 지수 * 2)"

Leo는 모든 음식의 스코빌 지수가 K 이상이 될 때까지 반복하여 섞습니다.
Leo가 가진 음식의 스코빌 지수를 담은 배열 scoville과 원하는 스코빌 지수 K가 주어질 때,
모든 음식의 스코빌 지수를 K 이상으로 만들기 위해 섞어야 하는 최소 횟수를 return 하도록 solution 함수를 작성해주세요.
```

단순하게 계속 정렬을 진행하면서 문제를 풀면 시간 초과로 문제를 해결 할 수 없게 됩니다    
따라서 파이썬의 우선순위 큐를 통해 매 반복마다효율적으로 리스트 내의 요소들을 관리 해야합니다.   



### solution
```
import heapq
def solution(scoville, K):
    answer = 0
    while scoville[0] < K and len(scoville) > 1:
        new_scoville = heapq.heappop(scoville) + (heapq.heappop(scoville) * 2)
        heapq.heappush(scoville , new_scoville)
        answer+=1
        
    if scoville[0] < K:
        return -1

    return answer
```

